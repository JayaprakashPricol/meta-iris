diff -Naur a/arch/arm/imx-common/cpu.c b/arch/arm/imx-common/cpu.c
--- a/arch/arm/imx-common/cpu.c	2020-09-07 09:01:43.162208799 +0530
+++ b/arch/arm/imx-common/cpu.c	2020-09-07 10:14:49.694128888 +0530
@@ -260,15 +260,15 @@
 
 void arch_preboot_os(void)
 {
-#if defined(CONFIG_CMD_SATA)
+/*#if defined(CONFIG_CMD_SATA)
 	sata_stop();
 #if defined(CONFIG_MX6)
 	disable_sata_clock();
 #endif
-#endif
-#if defined(CONFIG_LDO_BYPASS_CHECK)
+#endif*/
+/*#if defined(CONFIG_LDO_BYPASS_CHECK)
 	ldo_mode_set(check_ldo_bypass());
-#endif
+#endif*/
 #if defined(CONFIG_VIDEO_IPUV3)
 	/* disable video before launching O/S */
 	ipuv3_fb_shutdown();
@@ -277,9 +277,9 @@
 	/* Entry for GIS */
 	mxc_disable_gis();
 #endif
-#ifdef CONFIG_VIDEO_MXS
+/*#ifdef CONFIG_VIDEO_MXS
 	lcdif_power_down();
-#endif
+#endif*/
 }
 
 void set_chipselect_size(int const cs_size)
diff -Naur a/board/freescale/mx6qsabreauto/mx6qsabreauto.c b/board/freescale/mx6qsabreauto/mx6qsabreauto.c
--- a/board/freescale/mx6qsabreauto/mx6qsabreauto.c	2020-09-07 09:01:43.590208791 +0530
+++ b/board/freescale/mx6qsabreauto/mx6qsabreauto.c	2020-09-07 10:11:47.874132200 +0530
@@ -21,6 +21,7 @@
 #include <mmc.h>
 #include <fsl_esdhc.h>
 #include <miiphy.h>
+#include <micrel.h>
 #include <netdev.h>
 #include <asm/arch/sys_proto.h>
 #include <i2c.h>
@@ -31,65 +32,37 @@
 #include <power/pfuze100_pmic.h>
 #include "../common/pfuze.h"
 
-#ifdef CONFIG_CMD_SATA
-#include <asm/imx-common/sata.h>
-#endif
-#ifdef CONFIG_FSL_FASTBOOT
-#include <fsl_fastboot.h>
-#ifdef CONFIG_ANDROID_RECOVERY
-#include <recovery.h>
-#endif
-#endif /*CONFIG_FSL_FASTBOOT*/
-
-#ifdef CONFIG_MAX7310_IOEXP
-#include <gpio_exp.h>
-#endif
-
 DECLARE_GLOBAL_DATA_PTR;
 
-#define I2C_EXP_RST IMX_GPIO_NR(1, 15)
-#define I2C3_STEER  IMX_GPIO_NR(5, 4)
+/* UART PADDING CONFIG */
 #define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
 	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
 	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
 
+/* USDHC MEMORY CONTROLLER PADDING CONFIG */
 #define USDHC_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
 	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
 	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
 
-/*Need more drive strength for SD1 slot on base board*/
-#define USDHC1_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |            \
-	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |               \
-	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
-
+/* ETHERNET CONTROLLER PADDING CONFIG */
 #define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
 	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
 
+/* I2C PADDING CONFIG */
 #define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
 	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
 	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
 
-#define GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
-#define GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | \
-			PAD_CTL_SRE_FAST)
-#define GPMI_PAD_CTRL2 (GPMI_PAD_CTRL0 | GPMI_PAD_CTRL1)
-
-#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
-
+/* SPI FLASH PADDING CONFIG */
 #define SPI_PAD_CTRL (PAD_CTL_HYS |				\
 	PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_MED |		\
 	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
 
-#define WEIM_NOR_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |          \
-	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
-	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
-
+/* OTG CONTROLLER PADDING CONFIG */
 #define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
 	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
 	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
 
-#define I2C_PMIC	1
-
 int dram_init(void)
 {
 	gd->ram_size = get_ram_size((void *)PHYS_SDRAM, PHYS_SDRAM_SIZE);
@@ -97,11 +70,51 @@
 	return 0;
 }
 
-static iomux_v3_cfg_t const uart4_pads[] = {
-	MX6_PAD_KEY_COL0__UART4_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
-	MX6_PAD_KEY_ROW0__UART4_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX6_PAD_SD3_DAT7__UART1_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_SD3_DAT6__UART1_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+/*static struct i2c_pads_info i2c_pad_info1 = {
+        .scl = {
+                .i2c_mode = MX6_PAD_KEY_COL3__I2C2_SCL | PC,
+                .gpio_mode = MX6_PAD_KEY_COL3__GPIO4_IO12 | PC,
+                .gp = IMX_GPIO_NR(4, 12)
+        },
+        .sda = {
+                .i2c_mode = MX6_PAD_KEY_ROW3__I2C2_SDA | PC,
+                .gpio_mode = MX6_PAD_KEY_ROW3__GPIO4_IO13 | PC,
+                .gp = IMX_GPIO_NR(4, 13)
+        }
 };
 
+static struct i2c_pads_info i2c_pad_info2 = {
+        .scl = {
+                .i2c_mode = MX6_PAD_GPIO_3__I2C3_SCL | PC,
+                .gpio_mode = MX6_PAD_GPIO_3__GPIO1_IO03 | PC,
+                .gp = IMX_GPIO_NR(1, 3)
+        },
+        .sda = {
+                .i2c_mode = MX6_PAD_GPIO_6__I2C3_SDA | PC,
+                .gpio_mode = MX6_PAD_GPIO_6__GPIO1_IO06 | PC,
+                .gp = IMX_GPIO_NR(1, 6)
+        }
+};*/
+
+static iomux_v3_cfg_t const usdhc4_pads[] = {
+        MX6_PAD_SD4_CLK__SD4_CLK        | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+        MX6_PAD_SD4_CMD__SD4_CMD        | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+        MX6_PAD_SD4_DAT0__SD4_DATA0     | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+        MX6_PAD_SD4_DAT1__SD4_DATA1     | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+        MX6_PAD_SD4_DAT2__SD4_DATA2     | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+        MX6_PAD_SD4_DAT3__SD4_DATA3     | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+        MX6_PAD_SD4_DAT4__SD4_DATA4     | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+        MX6_PAD_SD4_DAT5__SD4_DATA5     | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+        MX6_PAD_SD4_DAT6__SD4_DATA6     | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+        MX6_PAD_SD4_DAT7__SD4_DATA7     | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+
 static iomux_v3_cfg_t const enet_pads[] = {
 	MX6_PAD_KEY_COL1__ENET_MDIO		| MUX_PAD_CTRL(ENET_PAD_CTRL),
 	MX6_PAD_KEY_COL2__ENET_MDC		| MUX_PAD_CTRL(ENET_PAD_CTRL),
@@ -118,99 +131,26 @@
 	MX6_PAD_RGMII_RD2__RGMII_RD2	| MUX_PAD_CTRL(ENET_PAD_CTRL),
 	MX6_PAD_RGMII_RD3__RGMII_RD3	| MUX_PAD_CTRL(ENET_PAD_CTRL),
 	MX6_PAD_RGMII_RX_CTL__RGMII_RX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_GPIO_16__ENET_REF_CLK		| MUX_PAD_CTRL(ENET_PAD_CTRL),
-};
-
-/* I2C2 PMIC, iPod, Tuner, Codec, Touch, HDMI EDID, MIPI CSI2 card */
-static struct i2c_pads_info i2c_pad_info1 = {
-	.scl = {
-		.i2c_mode = MX6_PAD_EIM_EB2__I2C2_SCL | PC,
-		.gpio_mode = MX6_PAD_EIM_EB2__GPIO2_IO30 | PC,
-		.gp = IMX_GPIO_NR(2, 30)
-	},
-	.sda = {
-		.i2c_mode = MX6_PAD_KEY_ROW3__I2C2_SDA | PC,
-		.gpio_mode = MX6_PAD_KEY_ROW3__GPIO4_IO13 | PC,
-		.gp = IMX_GPIO_NR(4, 13)
-	}
 };
 
-static iomux_v3_cfg_t const i2c3_pads[] = {
-	MX6_PAD_EIM_A24__GPIO5_IO04		| MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-
-static iomux_v3_cfg_t const port_exp[] = {
-	MX6_PAD_SD2_DAT0__GPIO1_IO15		| MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-
-#ifdef CONFIG_SYS_USE_EIMNOR
-static iomux_v3_cfg_t const eimnor_pads[] = {
-	MX6_PAD_EIM_D16__EIM_DATA16	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_D17__EIM_DATA17	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_D18__EIM_DATA18	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_D19__EIM_DATA19	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_D20__EIM_DATA20	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_D21__EIM_DATA21	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_D22__EIM_DATA22	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_D23__EIM_DATA23	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_D24__EIM_DATA24	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_D25__EIM_DATA25	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_D26__EIM_DATA26	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_D27__EIM_DATA27	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_D28__EIM_DATA28	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_D29__EIM_DATA29	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_D30__EIM_DATA30	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_D31__EIM_DATA31	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_DA0__EIM_AD00	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_DA1__EIM_AD01	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_DA2__EIM_AD02	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_DA3__EIM_AD03	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_DA4__EIM_AD04	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_DA5__EIM_AD05	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_DA6__EIM_AD06	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_DA7__EIM_AD07	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_DA8__EIM_AD08	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_DA9__EIM_AD09	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_DA10__EIM_AD10	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_DA11__EIM_AD11	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL) ,
-	MX6_PAD_EIM_DA12__EIM_AD12	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_DA13__EIM_AD13	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_DA14__EIM_AD14	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_DA15__EIM_AD15	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_A16__EIM_ADDR16	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_A17__EIM_ADDR17	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_A18__EIM_ADDR18	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_A19__EIM_ADDR19	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_A20__EIM_ADDR20	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_A21__EIM_ADDR21	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_A22__EIM_ADDR22	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_A23__EIM_ADDR23	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
-	MX6_PAD_EIM_OE__EIM_OE_B	| MUX_PAD_CTRL(NO_PAD_CTRL),
-	MX6_PAD_EIM_RW__EIM_RW		| MUX_PAD_CTRL(NO_PAD_CTRL),
-	MX6_PAD_EIM_CS0__EIM_CS0_B	| MUX_PAD_CTRL(NO_PAD_CTRL),
+#ifdef CONFIG_MXC_SPI
+iomux_v3_cfg_t const ecspi1_pads[] = {
+        MX6_PAD_EIM_D16__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+        MX6_PAD_EIM_D17__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+        MX6_PAD_EIM_D18__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+        MX6_PAD_EIM_D19__GPIO3_IO19  | MUX_PAD_CTRL(NO_PAD_CTRL),
 };
 
-static void eimnor_cs_setup(void)
+void setup_spinor(void)
 {
-	struct weim *weim_regs = (struct weim *)WEIM_BASE_ADDR;
-
-	writel(0x00020181, &weim_regs->cs0gcr1);
-	writel(0x00000001, &weim_regs->cs0gcr2);
-	writel(0x0a020000, &weim_regs->cs0rcr1);
-	writel(0x0000c000, &weim_regs->cs0rcr2);
-	writel(0x0804a240, &weim_regs->cs0wcr1);
-	writel(0x00000120, &weim_regs->wcr);
-
-	set_chipselect_size(CS0_128);
+        imx_iomux_v3_setup_multiple_pads(ecspi1_pads,
+                                         ARRAY_SIZE(ecspi1_pads));
+        gpio_direction_output(IMX_GPIO_NR(3, 19), 0);
 }
 
-static void setup_iomux_eimnor(void)
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
 {
-	imx_iomux_v3_setup_multiple_pads(eimnor_pads, ARRAY_SIZE(eimnor_pads));
-
-	gpio_direction_output(IMX_GPIO_NR(5, 4), 0);
-
-	eimnor_cs_setup();
+        return (bus == 0 && cs == 1) ? (IMX_GPIO_NR(3, 19)) : -1;
 }
 #endif
 
@@ -219,47 +159,15 @@
 	imx_iomux_v3_setup_multiple_pads(enet_pads, ARRAY_SIZE(enet_pads));
 }
 
-static iomux_v3_cfg_t const usdhc1_pads[] = {
-	/*To avoid pin conflict with NAND, set usdhc1 to 4 pins*/
-	MX6_PAD_SD1_CLK__SD1_CLK	| MUX_PAD_CTRL(USDHC1_PAD_CTRL),
-	MX6_PAD_SD1_CMD__SD1_CMD	| MUX_PAD_CTRL(USDHC1_PAD_CTRL),
-	MX6_PAD_SD1_DAT0__SD1_DATA0	| MUX_PAD_CTRL(USDHC1_PAD_CTRL),
-	MX6_PAD_SD1_DAT1__SD1_DATA1	| MUX_PAD_CTRL(USDHC1_PAD_CTRL),
-	MX6_PAD_SD1_DAT2__SD1_DATA2	| MUX_PAD_CTRL(USDHC1_PAD_CTRL),
-	MX6_PAD_SD1_DAT3__SD1_DATA3	| MUX_PAD_CTRL(USDHC1_PAD_CTRL),
-
-	/*CD pin*/
-	MX6_PAD_GPIO_1__GPIO1_IO01 | MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-
-static iomux_v3_cfg_t const usdhc3_pads[] = {
-	MX6_PAD_SD3_CLK__SD3_CLK	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD3_CMD__SD3_CMD	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD3_DAT0__SD3_DATA0	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD3_DAT1__SD3_DATA1	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD3_DAT2__SD3_DATA2	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD3_DAT3__SD3_DATA3	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD3_DAT4__SD3_DATA4	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD3_DAT5__SD3_DATA5	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD3_DAT6__SD3_DATA6	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD3_DAT7__SD3_DATA7	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_GPIO_18__SD3_VSELECT | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_NANDF_CS2__GPIO6_IO15   | MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-
 static void setup_iomux_uart(void)
 {
-	imx_iomux_v3_setup_multiple_pads(uart4_pads, ARRAY_SIZE(uart4_pads));
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
 }
 
 #ifdef CONFIG_FSL_ESDHC
 
-#define USDHC1_CD_GPIO	IMX_GPIO_NR(1, 1)
-#define USDHC3_CD_GPIO	IMX_GPIO_NR(6, 15)
-
-static struct fsl_esdhc_cfg usdhc_cfg[2] = {
-	{USDHC1_BASE_ADDR, 0, 4},
-	{USDHC3_BASE_ADDR},
+static struct fsl_esdhc_cfg usdhc_cfg[1] = {
+	{USDHC4_BASE_ADDR, 0, 4},
 };
 
 int mmc_get_env_devno(void)
@@ -280,6 +188,7 @@
 	/* need ubstract 1 to map to the mmc3 device id
 	 * see the comments in board_mmc_init function
 	 */
+
 	if (2 == dev_no)
 		dev_no--;
 
@@ -300,13 +209,8 @@
 	int ret = 0;
 
 	switch (cfg->esdhc_base) {
-	case USDHC1_BASE_ADDR:
-		gpio_direction_input(USDHC1_CD_GPIO);
-		ret = !gpio_get_value(USDHC1_CD_GPIO);
-		break;
-	case USDHC3_BASE_ADDR:
-		gpio_direction_input(USDHC3_CD_GPIO);
-		ret = !gpio_get_value(USDHC3_CD_GPIO);
+	case USDHC4_BASE_ADDR:
+		ret = 1;
 		break;
 	}
 
@@ -320,23 +224,16 @@
 	/*
 	* According to the board_mmc_init() the following map is done:
 	* (U-boot device node)    (Physical Port)
-	* mmc0				USDHC1
-	* mmc1				USDHC3
+	* mmc0				USDHC4
 	*/
+
 	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
 		switch (i) {
 		case 0:
 			imx_iomux_v3_setup_multiple_pads(
-				usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
-			gpio_direction_input(USDHC1_CD_GPIO);
+				usdhc4_pads, ARRAY_SIZE(usdhc4_pads));
 			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
 			break;
-		case 1:
-			imx_iomux_v3_setup_multiple_pads(
-				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
-			gpio_direction_input(USDHC3_CD_GPIO);
-			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
-			break;
 		default:
 			printf("Warning: you configured more USDHC controllers"
 				"(%d) than supported by the board\n", i + 1);
@@ -383,63 +280,50 @@
 }
 #endif
 
-#ifdef CONFIG_NAND_MXS
-static iomux_v3_cfg_t gpmi_pads[] = {
-	MX6_PAD_NANDF_CLE__NAND_CLE		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NANDF_ALE__NAND_ALE		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NANDF_WP_B__NAND_WP_B	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NANDF_RB0__NAND_READY_B	| MUX_PAD_CTRL(GPMI_PAD_CTRL0),
-	MX6_PAD_NANDF_CS0__NAND_CE0_B	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_SD4_CMD__NAND_RE_B		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_SD4_CLK__NAND_WE_B		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NANDF_D0__NAND_DATA00	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NANDF_D1__NAND_DATA01	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NANDF_D2__NAND_DATA02	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NANDF_D3__NAND_DATA03	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NANDF_D4__NAND_DATA04	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NANDF_D5__NAND_DATA05	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NANDF_D6__NAND_DATA06	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_NANDF_D7__NAND_DATA07	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
-	MX6_PAD_SD4_DAT0__NAND_DQS		| MUX_PAD_CTRL(GPMI_PAD_CTRL1),
-};
-
-static void setup_gpmi_nand(void)
-{
-	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
-
-	/* config gpmi nand iomux */
-	imx_iomux_v3_setup_multiple_pads(gpmi_pads, ARRAY_SIZE(gpmi_pads));
-
-	setup_gpmi_io_clk((MXC_CCM_CS2CDR_ENFC_CLK_PODF(0) |
-			MXC_CCM_CS2CDR_ENFC_CLK_PRED(3) |
-			MXC_CCM_CS2CDR_ENFC_CLK_SEL(3)));
-
-	/* enable apbh clock gating */
-	setbits_le32(&mxc_ccm->CCGR0, MXC_CCM_CCGR0_APBHDMA_MASK);
-}
-#endif
-
 int mx6_rgmii_rework(struct phy_device *phydev)
 {
-	unsigned short val;
+	if (strcasecmp(phydev->drv->name, "Micrel ksz9031") == 0 &&
+                        ((phydev->drv->uid & phydev->drv->mask) ==
+                         (phydev->phy_id & phydev->drv->mask))) {
+
+                //printf("Configuring PHY skew timing for %s\n",phydev->drv->name);
+
+                if (1) {
+                        if (ksz9031_phy_extended_write(phydev,MII_KSZ9031_EXT_MMD_ADD2,
+                                                MII_KSZ9031_EXT_RGMII_CTRL_SIG_SKEW, MII_KSZ9031_MOD_DATA_POST_INC_RW,0x0080) < 0)
+                                return -1;
+
+                        if (ksz9031_phy_extended_write(phydev,MII_KSZ9031_EXT_MMD_ADD2,
+                                                MII_KSZ9031_EXT_RGMII_RX_DATA_SKEW, MII_KSZ9031_MOD_DATA_POST_INC_RW,0x7787) < 0)
+                                return -1;
+                        if (ksz9031_phy_extended_write(phydev,MII_KSZ9031_EXT_MMD_ADD2,
+                                                MII_KSZ9031_EXT_RGMII_TX_DATA_SKEW, MII_KSZ9031_MOD_DATA_POST_INC_RW, 0x0000 ) < 0)
+                                return -1;
+                        if (ksz9031_phy_extended_write(phydev,MII_KSZ9031_EXT_MMD_ADD2,
+                                                MII_KSZ9031_EXT_RGMII_CLOCK_SKEW, MII_KSZ9031_MOD_DATA_POST_INC_RW,0x03ff) < 0)
+                                return -1;
+                }
+                else
+                {
+                        if (ksz9031_phy_extended_write(phydev,MII_KSZ9031_EXT_MMD_ADD2,
+                                                MII_KSZ9031_EXT_RGMII_CTRL_SIG_SKEW, MII_KSZ9031_MOD_DATA_POST_INC_RW, 0x00C7) < 0)
+                                return -1;
+
+                        if (ksz9031_phy_extended_write(phydev,MII_KSZ9031_EXT_MMD_ADD2,
+                                                MII_KSZ9031_EXT_RGMII_RX_DATA_SKEW, MII_KSZ9031_MOD_DATA_NO_POST_INC, 0xBB5A) < 0)
+                                return -1;
+                        if (ksz9031_phy_extended_write(phydev,MII_KSZ9031_EXT_MMD_ADD2,
+                                                MII_KSZ9031_EXT_RGMII_TX_DATA_SKEW, MII_KSZ9031_MOD_DATA_POST_INC_RW, 0x7777) < 0)
+                                return -1;
+                        if (ksz9031_phy_extended_write(phydev,MII_KSZ9031_EXT_MMD_ADD2,
+                                                MII_KSZ9031_EXT_RGMII_CLOCK_SKEW, MII_KSZ9031_MOD_DATA_POST_INC_RW, 0x039C) < 0)
+                                return -1;
+                }
 
-	/* To enable AR8031 ouput a 125MHz clk from CLK_25M */
-	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x7);
-	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, 0x8016);
-	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x4007);
-
-	val = phy_read(phydev, MDIO_DEVAD_NONE, 0xe);
-	val &= 0xffe3;
-	val |= 0x18;
-	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, val);
-
-	/* introduce tx clock delay */
-	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x5);
-	val = phy_read(phydev, MDIO_DEVAD_NONE, 0x1e);
-	val |= 0x0100;
-	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, val);
+        }
+
+        return 0;
 
-	return 0;
 }
 
 int board_phy_config(struct phy_device *phydev)
@@ -514,226 +398,20 @@
 	return (get_cpu_rev() & ~(0xF << 8)) | rev;
 }
 
-#if defined(CONFIG_VIDEO_IPUV3)
-static void disable_lvds(struct display_info_t const *dev)
-{
-	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
-
-	int reg = readl(&iomux->gpr[2]);
-
-	reg &= ~(IOMUXC_GPR2_LVDS_CH0_MODE_MASK |
-		 IOMUXC_GPR2_LVDS_CH1_MODE_MASK);
-
-	writel(reg, &iomux->gpr[2]);
-}
-
-static void do_enable_hdmi(struct display_info_t const *dev)
-{
-	disable_lvds(dev);
-	imx_enable_hdmi_phy();
-}
-
-struct display_info_t const displays[] = {{
-	.bus	= -1,
-	.addr	= 0,
-	.pixfmt	= IPU_PIX_FMT_RGB666,
-	.detect	= NULL,
-	.enable	= NULL,
-	.mode	= {
-		.name           = "Hannstar-XGA",
-		.refresh        = 60,
-		.xres           = 1024,
-		.yres           = 768,
-		.pixclock       = 15385,
-		.left_margin    = 220,
-		.right_margin   = 40,
-		.upper_margin   = 21,
-		.lower_margin   = 7,
-		.hsync_len      = 60,
-		.vsync_len      = 10,
-		.sync           = FB_SYNC_EXT,
-		.vmode          = FB_VMODE_NONINTERLACED
-} }, {
-	.bus	= -1,
-	.addr	= 0,
-	.pixfmt	= IPU_PIX_FMT_RGB24,
-	.detect	= NULL,
-	.enable	= do_enable_hdmi,
-	.mode	= {
-		.name           = "HDMI",
-		.refresh        = 60,
-		.xres           = 640,
-		.yres           = 480,
-		.pixclock       = 39721,
-		.left_margin    = 48,
-		.right_margin   = 16,
-		.upper_margin   = 33,
-		.lower_margin   = 10,
-		.hsync_len      = 96,
-		.vsync_len      = 2,
-		.sync           = 0,
-		.vmode          = FB_VMODE_NONINTERLACED
-} } };
-size_t display_count = ARRAY_SIZE(displays);
-
-iomux_v3_cfg_t const backlight_pads[] = {
-	MX6_PAD_SD4_DAT1__GPIO2_IO09 | MUX_PAD_CTRL(ENET_PAD_CTRL),
-};
-
-static void setup_iomux_backlight(void)
-{
-	gpio_direction_output(IMX_GPIO_NR(2, 9), 1);
-	imx_iomux_v3_setup_multiple_pads(backlight_pads,
-					 ARRAY_SIZE(backlight_pads));
-}
-
-static void setup_display(void)
-{
-	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
-	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
-	int reg;
-
-	setup_iomux_backlight();
-	enable_ipu_clock();
-	imx_setup_hdmi();
-
-	/* Turn on LDB_DI0 and LDB_DI1 clocks */
-	reg = readl(&mxc_ccm->CCGR3);
-	reg |= MXC_CCM_CCGR3_LDB_DI0_MASK | MXC_CCM_CCGR3_LDB_DI1_MASK;
-	writel(reg, &mxc_ccm->CCGR3);
-
-	/* Set LDB_DI0 and LDB_DI1 clk select to 3b'011 */
-	reg = readl(&mxc_ccm->cs2cdr);
-	reg &= ~(MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK |
-		 MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK);
-	reg |= (3 << MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_OFFSET) |
-	       (3 << MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_OFFSET);
-	writel(reg, &mxc_ccm->cs2cdr);
-
-	reg = readl(&mxc_ccm->cscmr2);
-	reg |= MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV | MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV;
-	writel(reg, &mxc_ccm->cscmr2);
-
-	reg = readl(&mxc_ccm->chsccdr);
-	reg |= (CHSCCDR_CLK_SEL_LDB_DI0 <<
-		MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET);
-	reg |= (CHSCCDR_CLK_SEL_LDB_DI0 <<
-		MXC_CCM_CHSCCDR_IPU1_DI1_CLK_SEL_OFFSET);
-	writel(reg, &mxc_ccm->chsccdr);
-
-	reg = IOMUXC_GPR2_DI1_VS_POLARITY_ACTIVE_LOW |
-	      IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_LOW |
-	      IOMUXC_GPR2_BIT_MAPPING_CH1_SPWG |
-	      IOMUXC_GPR2_DATA_WIDTH_CH1_18BIT |
-	      IOMUXC_GPR2_BIT_MAPPING_CH0_SPWG |
-	      IOMUXC_GPR2_DATA_WIDTH_CH0_18BIT |
-	      IOMUXC_GPR2_LVDS_CH0_MODE_ENABLED_DI0 |
-	      IOMUXC_GPR2_LVDS_CH1_MODE_DISABLED;
-	writel(reg, &iomux->gpr[2]);
-
-	reg = readl(&iomux->gpr[3]);
-	reg &= ~(IOMUXC_GPR3_LVDS0_MUX_CTL_MASK |
-		 IOMUXC_GPR3_HDMI_MUX_CTL_MASK);
-	reg |= (IOMUXC_GPR3_MUX_SRC_IPU1_DI0 <<
-		IOMUXC_GPR3_LVDS0_MUX_CTL_OFFSET) |
-	       (IOMUXC_GPR3_MUX_SRC_IPU1_DI0 <<
-		IOMUXC_GPR3_HDMI_MUX_CTL_OFFSET);
-	writel(reg, &iomux->gpr[3]);
-}
-#endif /* CONFIG_VIDEO_IPUV3 */
-
 /*
  * Do not overwrite the console
  * Use always serial for U-Boot console
  */
+
 int overwrite_console(void)
 {
 	return 1;
 }
 
-#ifdef CONFIG_MAX7310_IOEXP
-/*
- * I2C3 MLB, Port Expanders (A, B, C), Video ADC, Light Sensor,
- * Compass Sensor, Accelerometer, Res Touch
- */
-static struct i2c_pads_info i2c_pad_info2 = {
-	.scl = {
-		.i2c_mode = MX6_PAD_GPIO_3__I2C3_SCL | PC,
-		.gpio_mode = MX6_PAD_GPIO_3__GPIO1_IO03 | PC,
-		.gp = IMX_GPIO_NR(1, 3)
-	},
-	.sda = {
-		.i2c_mode = MX6_PAD_EIM_D18__I2C3_SDA | PC,
-		.gpio_mode = MX6_PAD_EIM_D18__GPIO3_IO18 | PC,
-		.gp = IMX_GPIO_NR(3, 18)
-	}
-};
-
-void reset_max7310(void)
-{
-	gpio_direction_output(I2C_EXP_RST, 1);
-	imx_iomux_v3_setup_multiple_pads(port_exp,
-					 ARRAY_SIZE(port_exp));
-}
-
-int setup_max7310(void)
-{
-#ifdef CONFIG_SYS_I2C_MXC
-	/*
-	 * set steering config to i2c,
-	 * note: this causes pin conflicts with eimnor and spinor
-	 */
-	gpio_direction_output(IMX_GPIO_NR(5, 4), 1);
-	imx_iomux_v3_setup_multiple_pads(i2c3_pads,
-					ARRAY_SIZE(i2c3_pads));
-
-	/*setup i2c info 2*/
-	setup_i2c(2, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
-
-	gpio_exp_setup_port(1, 2, 0x30);
-	gpio_exp_setup_port(2, 2, 0x32);
-	gpio_exp_setup_port(3, 2, 0x34);
-
-	return 0;
-#else
-	return -EPERM;
-#endif
-}
-#endif
-
-#ifdef CONFIG_MXC_SPI
-iomux_v3_cfg_t const ecspi1_pads[] = {
-	MX6_PAD_EIM_D16__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
-	MX6_PAD_EIM_D17__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
-	MX6_PAD_EIM_D18__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
-	MX6_PAD_EIM_D19__GPIO3_IO19  | MUX_PAD_CTRL(NO_PAD_CTRL),
-	/* Steer logic */
-	MX6_PAD_EIM_A24__GPIO5_IO04  | MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-
-void setup_spinor(void)
-{
-	imx_iomux_v3_setup_multiple_pads(ecspi1_pads,
-					 ARRAY_SIZE(ecspi1_pads));
-	gpio_direction_output(IMX_GPIO_NR(5, 4), 0);
-	gpio_direction_output(IMX_GPIO_NR(3, 19), 0);
-}
-
-int board_spi_cs_gpio(unsigned bus, unsigned cs)
-{
-	return (bus == 0 && cs == 1) ? (IMX_GPIO_NR(3, 19)) : -1;
-}
-#endif
-
 int board_early_init_f(void)
 {
 	setup_iomux_uart();
 
-#ifdef CONFIG_MAX7310_IOEXP
-	/*Reset gpio expander at early stage*/
-	reset_max7310();
-#endif
-
 	return 0;
 }
 
@@ -742,147 +420,23 @@
 	/* address of boot parameters */
 	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
 
-#ifdef CONFIG_MAX7310_IOEXP
-	setup_max7310();
-#endif
-	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
-
-#ifdef CONFIG_VIDEO_IPUV3
-	setup_display();
-#endif
+	//setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	//setup_i2c(2, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
 
 #ifdef CONFIG_MXC_SPI
 	setup_spinor();
 #endif
 
-#ifdef CONFIG_NAND_MXS
-	setup_gpmi_nand();
-#endif
-
-#ifdef CONFIG_CMD_SATA
-	setup_sata();
-#endif
-
-#ifdef CONFIG_SYS_USE_EIMNOR
-	setup_iomux_eimnor();
-#endif
 	return 0;
 }
 
-static struct pmic *pfuze;
-int power_init_board(void)
-{
-	unsigned int value;
-	int ret;
-
-	pfuze = pfuze_common_init(I2C_PMIC);
-	if (!pfuze)
-		return -ENODEV;
-
-	if (is_mx6dqp())
-		ret = pfuze_mode_init(pfuze, APS_APS);
-	else
-		ret = pfuze_mode_init(pfuze, APS_PFM);
-
-	if (ret < 0)
-		return ret;
-
-	if (is_mx6dqp()) {
-		/* set SW1C staby volatage 1.075V*/
-		pmic_reg_read(pfuze, PFUZE100_SW1CSTBY, &value);
-		value &= ~0x3f;
-		value |= 0x1f;
-		pmic_reg_write(pfuze, PFUZE100_SW1CSTBY, value);
-
-		/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
-		pmic_reg_read(pfuze, PFUZE100_SW1CCONF, &value);
-		value &= ~0xc0;
-		value |= 0x40;
-		pmic_reg_write(pfuze, PFUZE100_SW1CCONF, value);
-
-		/* set SW2 staby volatage 0.975V*/
-		pmic_reg_read(pfuze, PFUZE100_SW2STBY, &value);
-		value &= ~0x3f;
-		value |= 0x17;
-		pmic_reg_write(pfuze, PFUZE100_SW2STBY, value);
-
-		/* set SW2/VDDARM step ramp up time to from 16us to 4us/25mV */
-		pmic_reg_read(pfuze, PFUZE100_SW2CONF, &value);
-		value &= ~0xc0;
-		value |= 0x40;
-		pmic_reg_write(pfuze, PFUZE100_SW2CONF, value);
-	} else {
-		/* set SW1AB staby volatage 0.975V*/
-		pmic_reg_read(pfuze, PFUZE100_SW1ABSTBY, &value);
-		value &= ~0x3f;
-		value |= 0x1b;
-		pmic_reg_write(pfuze, PFUZE100_SW1ABSTBY, value);
-
-		/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
-		pmic_reg_read(pfuze, PFUZE100_SW1ABCONF, &value);
-		value &= ~0xc0;
-		value |= 0x40;
-		pmic_reg_write(pfuze, PFUZE100_SW1ABCONF, value);
-
-		/* set SW1C staby volatage 0.975V*/
-		pmic_reg_read(pfuze, PFUZE100_SW1CSTBY, &value);
-		value &= ~0x3f;
-		value |= 0x1b;
-		pmic_reg_write(pfuze, PFUZE100_SW1CSTBY, value);
-
-		/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
-		pmic_reg_read(pfuze, PFUZE100_SW1CCONF, &value);
-		value &= ~0xc0;
-		value |= 0x40;
-		pmic_reg_write(pfuze, PFUZE100_SW1CCONF, value);
-	}
-
-	return 0;
-}
-
-#ifdef CONFIG_LDO_BYPASS_CHECK
-void ldo_mode_set(int ldo_bypass)
-{
-	unsigned int value;
-	struct pmic *p = pfuze;
-
-	if (!p) {
-		printf("No PMIC found!\n");
-		return;
-	}
-
-	/* increase VDDARM/VDDSOC to support 1.2G chip */
-	if (check_1_2G()) {
-		ldo_bypass = 0;	/* ldo_enable on 1.2G chip */
-		printf("1.2G chip, increase VDDARM_IN/VDDSOC_IN\n");
-
-		if (is_mx6dqp()) {
-			/* increase VDDARM to 1.425V */
-			pmic_reg_read(p, PFUZE100_SW2VOL, &value);
-			value &= ~0x3f;
-			value |= 0x29;
-			pmic_reg_write(p, PFUZE100_SW2VOL, value);
-		} else {
-			/* increase VDDARM to 1.425V */
-			pmic_reg_read(p, PFUZE100_SW1ABVOL, &value);
-			value &= ~0x3f;
-			value |= 0x2d;
-			pmic_reg_write(p, PFUZE100_SW1ABVOL, value);
-		}
-		/* increase VDDSOC to 1.425V */
-		pmic_reg_read(p, PFUZE100_SW1CVOL, &value);
-		value &= ~0x3f;
-		value |= 0x2d;
-		pmic_reg_write(p, PFUZE100_SW1CVOL, value);
-	}
-}
-#endif
-
 #ifdef CONFIG_CMD_BMODE
 static const struct boot_mode board_boot_modes[] = {
-	/* 4 bit bus width */
-	{"mmc0", MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
-	{NULL,   0},
+	/* 8 bit bus width */
+        {"emmc",  MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},
+        /* spi flash */
+        {"spi",   MAKE_CFGVAL(0x30, 0x00, 0x00, 0x00)},
+        {NULL,   0},
 };
 #endif
 
@@ -918,176 +472,3 @@
 
 	return 0;
 }
-
-#ifdef CONFIG_USB_EHCI_MX6
-#define USB_HOST1_PWR     IOEXP_GPIO_NR(2, 7)
-#define USB_OTG_PWR       IOEXP_GPIO_NR(3, 1)
-
-iomux_v3_cfg_t const usb_otg_pads[] = {
-	MX6_PAD_ENET_RX_ER__USB_OTG_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
-};
-
-int board_ehci_hcd_init(int port)
-{
-	switch (port) {
-	case 0:
-		imx_iomux_v3_setup_multiple_pads(usb_otg_pads,
-			ARRAY_SIZE(usb_otg_pads));
-
-		/*
-		  * Set daisy chain for otg_pin_id on 6q.
-		 *  For 6dl, this bit is reserved.
-		 */
-		imx_iomux_set_gpr_register(1, 13, 1, 0);
-		break;
-	case 1:
-		break;
-	default:
-		printf("MXC USB port %d not yet supported\n", port);
-		return -EINVAL;
-	}
-	return 0;
-}
-
-int board_ehci_power(int port, int on)
-{
-	switch (port) {
-	case 0:
-		if (on)
-			gpio_exp_direction_output(USB_OTG_PWR, 1);
-		else
-			gpio_exp_direction_output(USB_OTG_PWR, 0);
-		break;
-	case 1:
-		if (on)
-			gpio_exp_direction_output(USB_HOST1_PWR, 1);
-		else
-			gpio_exp_direction_output(USB_HOST1_PWR, 0);
-		break;
-	default:
-		printf("MXC USB port %d not yet supported\n", port);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-#endif
-
-#ifdef CONFIG_FSL_FASTBOOT
-
-void board_fastboot_setup(void)
-{
-	switch (get_boot_device()) {
-#if defined(CONFIG_FASTBOOT_STORAGE_SATA)
-	case SATA_BOOT:
-		if (!getenv("fastboot_dev"))
-			setenv("fastboot_dev", "sata");
-		if (!getenv("bootcmd"))
-			setenv("bootcmd", "boota sata");
-		break;
-#endif /*CONFIG_FASTBOOT_STORAGE_SATA*/
-#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
-	case SD1_BOOT:
-	case MMC1_BOOT:
-		if (!getenv("fastboot_dev"))
-			setenv("fastboot_dev", "mmc0");
-		if (!getenv("bootcmd"))
-			setenv("bootcmd", "boota mmc0");
-		break;
-	case SD3_BOOT:
-	case MMC3_BOOT:
-		if (!getenv("fastboot_dev"))
-			setenv("fastboot_dev", "mmc1");
-		if (!getenv("bootcmd"))
-			setenv("bootcmd", "boota mmc1");
-		break;
-#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
-#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
-	case NAND_BOOT:
-		if (!getenv("fastboot_dev"))
-			setenv("fastboot_dev", "nand");
-		if (!getenv("fbparts"))
-			setenv("fbparts", ANDROID_FASTBOOT_NAND_PARTS);
-		if (!getenv("bootcmd"))
-			setenv("bootcmd",
-				"nand read ${loadaddr} ${boot_nand_offset} "
-				"${boot_nand_size};boota ${loadaddr}");
-		break;
-#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
-	default:
-		printf("unsupported boot devices\n");
-		break;
-	}
-}
-
-#ifdef CONFIG_ANDROID_RECOVERY
-
-#define GPIO_VOL_DN_KEY IMX_GPIO_NR(5, 14)
-iomux_v3_cfg_t const recovery_key_pads[] = {
-	(MX6_PAD_DISP0_DAT20__GPIO5_IO14 | MUX_PAD_CTRL(NO_PAD_CTRL)),
-};
-
-int check_recovery_cmd_file(void)
-{
-	int button_pressed = 0;
-	int recovery_mode = 0;
-
-	recovery_mode = recovery_check_and_clean_flag();
-
-	/* Check Recovery Combo Button press or not. */
-	imx_iomux_v3_setup_multiple_pads(recovery_key_pads,
-		ARRAY_SIZE(recovery_key_pads));
-
-	gpio_direction_input(GPIO_VOL_DN_KEY);
-
-	if (gpio_get_value(GPIO_VOL_DN_KEY) == 0) { /* VOL_DN key is low assert */
-		button_pressed = 1;
-		printf("Recovery key pressed\n");
-	}
-
-	return recovery_mode || button_pressed;
-}
-
-void board_recovery_setup(void)
-{
-	int bootdev = get_boot_device();
-
-	switch (bootdev) {
-#if defined(CONFIG_FASTBOOT_STORAGE_SATA)
-	case SATA_BOOT:
-		if (!getenv("bootcmd_android_recovery"))
-			setenv("bootcmd_android_recovery", "boota sata recovery");
-		break;
-#endif /*CONFIG_FASTBOOT_STORAGE_SATA*/
-#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
-	case SD1_BOOT:
-	case MMC1_BOOT:
-		if (!getenv("bootcmd_android_recovery"))
-			setenv("bootcmd_android_recovery", "boota mmc0 recovery");
-		break;
-	case SD3_BOOT:
-	case MMC3_BOOT:
-		if (!getenv("bootcmd_android_recovery"))
-			setenv("bootcmd_android_recovery", "boota mmc1 recovery");
-		break;
-#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
-#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
-	case NAND_BOOT:
-		if (!getenv("bootcmd_android_recovery"))
-			setenv("bootcmd_android_recovery",
-				"nand read ${loadaddr} ${recovery_nand_offset} "
-				"${recovery_nand_size};boota ${loadaddr}");
-		break;
-#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
-	default:
-		printf("Unsupported bootup device for recovery: dev: %d\n",
-			bootdev);
-		return;
-	}
-
-	printf("setup env for recovery..\n");
-	setenv("bootcmd", "run bootcmd_android_recovery");
-}
-#endif /*CONFIG_ANDROID_RECOVERY*/
-
-#endif /*CONFIG_FSL_FASTBOOT*/
diff -Naur a/drivers/mtd/spi/sf_params.c b/drivers/mtd/spi/sf_params.c
--- a/drivers/mtd/spi/sf_params.c	2020-09-07 09:01:44.154208781 +0530
+++ b/drivers/mtd/spi/sf_params.c	2020-09-07 10:33:33.998108406 +0530
@@ -25,6 +25,49 @@
 	{"AT45DB641D",	   0x1f2800, 0x0,	64 * 1024,   128, RD_NORM,		    SECT_4K},
 	{"AT25DF321",      0x1f4701, 0x0,	64 * 1024,    64, RD_NORM,		    SECT_4K},
 #endif
+#ifdef CONFIG_SPI_FLASH_ISSI		/* ISSI - 4K, 32K, 64K Sec/Blk Size all available */
+    {"is25lp080d",     0x9d6014, 0x0, 64 * 1024,    16, RD_FULL, WR_QPP | SECT_4K},
+    {"is25lp016d",     0x9d6015, 0x0, 64 * 1024,    32, RD_FULL, WR_QPP | SECT_4K},
+    {"is25lp032d",     0x9d6016, 0x0, 64 * 1024,    64, RD_FULL, WR_QPP | SECT_4K},
+    {"is25lp064a",     0x9d6017, 0x0, 64 * 1024,   128, RD_FULL, WR_QPP | SECT_4K},
+    {"is25lp064d",     0x9d6017, 0x0, 64 * 1024,   128, RD_FULL, WR_QPP | SECT_4K},
+    {"is25lp128",      0x9d6018, 0x0, 64 * 1024,   256, RD_FULL, WR_QPP | SECT_4K},
+    {"is25lp128f",     0x9d6018, 0x0, 64 * 1024,   256, RD_FULL, WR_QPP | SECT_4K},
+    {"is25lp256d",     0x9d6019, 0x0, 64 * 1024,   512, RD_FULL, WR_QPP | SECT_4K},
+    {"is25lp512m",     0x9d601A, 0x0, 64 * 1024,  1024, RD_FULL, WR_QPP | SECT_4K},
+    {"is25lp01g",      0x9d601B, 0x0, 64 * 1024,  2048, RD_FULL, WR_QPP | SECT_4K},
+																				 
+    {"is25wp020d",     0x9d7012, 0x0, 64 * 1024,     4, RD_FULL, WR_QPP | SECT_4K},
+    {"is25wp040d",     0x9d7013, 0x0, 64 * 1024,     8, RD_FULL, WR_QPP | SECT_4K},
+    {"is25wp080d",     0x9d7014, 0x0, 64 * 1024,    16, RD_FULL, WR_QPP | SECT_4K},
+    {"is25wp016d",     0x9d7015, 0x0, 64 * 1024,    32, RD_FULL, WR_QPP | SECT_4K},
+    {"is25wp032d",     0x9d7016, 0x0, 64 * 1024,    64, RD_FULL, WR_QPP | SECT_4K},
+    {"is25wp064a",     0x9d7017, 0x0, 64 * 1024,   128, RD_FULL, WR_QPP | SECT_4K},
+    {"is25wp064d",     0x9d7017, 0x0, 64 * 1024,   128, RD_FULL, WR_QPP | SECT_4K},
+    {"is25wp128",      0x9d7018, 0x0, 64 * 1024,   256, RD_FULL, WR_QPP | SECT_4K},
+    {"is25wp128f",     0x9d7018, 0x0, 64 * 1024,   256, RD_FULL, WR_QPP | SECT_4K},
+    {"is25wp256d",     0x9d7019, 0x0, 64 * 1024,   512, RD_FULL, WR_QPP | SECT_4K},
+    {"is25wp512m",     0x9d701A, 0x0, 64 * 1024,  1024, RD_FULL, WR_QPP | SECT_4K},
+    {"is25wp01g",      0x9d701B, 0x0, 64 * 1024,  2048, RD_FULL, WR_QPP | SECT_4K},
+
+    {"is25le128e_64k",  0x9d6018, 0x0, 64 * 1024,   256, RD_FULL, WR_QPP | SECT_4K},
+    {"is25le256e_64k",  0x9d6019, 0x0, 64 * 1024,   512, RD_FULL, WR_QPP | SECT_4K},
+    {"is25le512m_64k",  0x9d601A, 0x0, 64 * 1024,  1024, RD_FULL, WR_QPP | SECT_4K},
+    {"is25le01g_64k",   0x9d601B, 0x0, 64 * 1024,  2048, RD_FULL, WR_QPP | SECT_4K},
+    {"is25le128e_256k",  0x9d6018, 0x0, 256 * 1024,   64, RD_FULL, WR_QPP | SECT_4K},
+    {"is25le256e_256k",  0x9d6019, 0x0, 256 * 1024,  128, RD_FULL, WR_QPP | SECT_4K},
+    {"is25le512m_256k",  0x9d601A, 0x0, 256 * 1024,  256, RD_FULL, WR_QPP | SECT_4K},
+    {"is25le01g_256k",   0x9d601B, 0x0, 256 * 1024,  512, RD_FULL, WR_QPP | SECT_4K},
+
+    {"is25we128e_64k",  0x9d7018, 0x0, 64 * 1024,   256, RD_FULL, WR_QPP | SECT_4K},
+    {"is25we256e_64k",  0x9d7019, 0x0, 64 * 1024,   512, RD_FULL, WR_QPP | SECT_4K},
+    {"is25we512m_64k",  0x9d701A, 0x0, 64 * 1024,  1024, RD_FULL, WR_QPP | SECT_4K},
+    {"is25we01g_64k",   0x9d701B, 0x0, 64 * 1024,  2048, RD_FULL, WR_QPP | SECT_4K},
+    {"is25we128e_256k",  0x9d7018, 0x0, 256 * 1024,   64, RD_FULL, WR_QPP | SECT_4K},
+    {"is25we256e_256k",  0x9d7019, 0x0, 256 * 1024,  128, RD_FULL, WR_QPP | SECT_4K},
+    {"is25we512m_256k",  0x9d701A, 0x0, 256 * 1024,  256, RD_FULL, WR_QPP | SECT_4K},
+    {"is25we01g_256k",   0x9d701B, 0x0, 256 * 1024,  512, RD_FULL, WR_QPP | SECT_4K},
+#endif
 #ifdef CONFIG_SPI_FLASH_EON		/* EON */
 	{"EN25Q32B",	   0x1c3016, 0x0,	64 * 1024,    64, RD_NORM,			  0},
 	{"EN25Q64",	   0x1c3017, 0x0,	64 * 1024,   128, RD_NORM,		    SECT_4K},
diff -Naur a/include/configs/mx6qsabreauto.h b/include/configs/mx6qsabreauto.h
--- a/include/configs/mx6qsabreauto.h	2020-09-07 09:01:44.566208773 +0530
+++ b/include/configs/mx6qsabreauto.h	2020-09-07 10:43:30.030097548 +0530
@@ -10,30 +10,18 @@
 #define __MX6QSABREAUTO_CONFIG_H
 
 #define CONFIG_MACH_TYPE	3529
-#define CONFIG_MXC_UART_BASE	UART4_BASE
-#define CONFIG_CONSOLE_DEV		"ttymxc3"
+#define CONFIG_MXC_UART_BASE	UART1_BASE
+#define CONFIG_CONSOLE_DEV		"ttymxc0"
 #define CONFIG_MMCROOT			"/dev/mmcblk2p2"  /* SDHC3 */
-#if defined CONFIG_MX6QP
-#define CONFIG_DEFAULT_FDT_FILE	"imx6qp-sabreauto.dtb"
-#define PHYS_SDRAM_SIZE		(2u * 1024 * 1024 * 1024)
-#elif defined CONFIG_MX6Q
-#define CONFIG_DEFAULT_FDT_FILE	"imx6q-sabreauto.dtb"
-#define PHYS_SDRAM_SIZE		(2u * 1024 * 1024 * 1024)
-#elif defined(CONFIG_MX6DL)
-#define CONFIG_DEFAULT_FDT_FILE	"imx6dl-sabreauto.dtb"
-#define PHYS_SDRAM_SIZE		(2u * 1024 * 1024 * 1024)
-#elif defined(CONFIG_MX6SOLO)
+
+#if defined CONFIG_MX6SOLO
 #define CONFIG_DEFAULT_FDT_FILE	"imx6dl-sabreauto.dtb"
 #define PHYS_SDRAM_SIZE		(1u * 1024 * 1024 * 1024)
 #endif
 
-#define CONFIG_SYS_USE_NAND
-
 #include "mx6sabre_common.h"
 #include <asm/imx-common/gpio.h>
 
-/*Since the pin conflicts on EIM D18, disable the USB host if the NOR flash is enabled */
-#if !defined(CONFIG_SYS_USE_SPINOR) && !defined(CONFIG_SYS_USE_EIMNOR)
 /* USB Configs */
 #define CONFIG_CMD_USB
 #define CONFIG_USB_EHCI
@@ -46,60 +34,19 @@
 #define CONFIG_MXC_USB_PORTSC	(PORT_PTS_UTMI | PORT_PTS_PTW)
 #define CONFIG_MXC_USB_FLAGS	0
 
-/* MAX7310 configs */
-#define CONFIG_MAX7310_IOEXP
-#define CONFIG_IOEXP_DEVICES_NUM 3
-#define CONFIG_IOEXP_DEV_PINS_NUM 8
-#endif
-
-#undef CONFIG_MFG_NAND_PARTITION
-#ifdef CONFIG_SYS_BOOT_NAND
-#define CONFIG_MFG_NAND_PARTITION "mtdparts=8000000.nor:1m(boot),-(rootfs)\\\\;gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs) "
-#else
-#define CONFIG_MFG_NAND_PARTITION ""
-#endif
-
-#ifdef CONFIG_SYS_USE_EIMNOR
-#undef CONFIG_SYS_NO_FLASH
-#define CONFIG_SYS_FLASH_BASE           WEIM_ARB_BASE_ADDR
-#define CONFIG_SYS_FLASH_SECT_SIZE      (128 * 1024)
-#define CONFIG_SYS_MAX_FLASH_BANKS 1    /* max number of memory banks */
-#define CONFIG_SYS_MAX_FLASH_SECT 256   /* max number of sectors on one chip */
-#define CONFIG_SYS_FLASH_CFI            /* Flash memory is CFI compliant */
-#define CONFIG_FLASH_CFI_DRIVER         /* Use drivers/cfi_flash.c */
-#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE /* Use buffered writes*/
-#define CONFIG_SYS_FLASH_EMPTY_INFO
-#endif
-
-#define CONFIG_SYS_FSL_USDHC_NUM	2
-#define CONFIG_SYS_MMC_ENV_DEV		1  /* SDHC3 */
+#define CONFIG_SYS_FSL_USDHC_NUM	1
+#define CONFIG_SYS_MMC_ENV_DEV		0  /* SDHC4 */
 #define CONFIG_SYS_MMC_ENV_PART                0       /* user partition */
-
 #ifdef CONFIG_SYS_USE_SPINOR
 #define CONFIG_SF_DEFAULT_CS   1
 #endif
+
 /* I2C Configs */
 #define CONFIG_CMD_I2C
 #define CONFIG_SYS_I2C
 #define CONFIG_SYS_I2C_MXC
 #define CONFIG_SYS_I2C_SPEED		100000
 
-/* NAND flash command */
-#define CONFIG_CMD_NAND
-#define CONFIG_CMD_NAND_TRIMFFS
-
-/* NAND stuff */
-#define CONFIG_NAND_MXS
-#define CONFIG_SYS_MAX_NAND_DEVICE     1
-#define CONFIG_SYS_NAND_BASE           0x40000000
-#define CONFIG_SYS_NAND_5_ADDR_CYCLE
-#define CONFIG_SYS_NAND_ONFI_DETECTION
-
-/* DMA stuff, needed for GPMI/MXS NAND support */
-#define CONFIG_APBH_DMA
-#define CONFIG_APBH_DMA_BURST
-#define CONFIG_APBH_DMA_BURST8
-
 /* PMIC */
 #define CONFIG_POWER
 #define CONFIG_POWER_I2C
diff -Naur a/include/configs/mx6sabre_common.h b/include/configs/mx6sabre_common.h
--- a/include/configs/mx6sabre_common.h	2020-09-07 09:01:44.566208773 +0530
+++ b/include/configs/mx6sabre_common.h	2020-09-07 10:47:13.918093470 +0530
@@ -40,18 +40,14 @@
 #define CONFIG_SETUP_MEMORY_TAGS
 #define CONFIG_INITRD_TAG
 #define CONFIG_REVISION_TAG
-
 #define CONFIG_SYS_GENERIC_BOARD
 
 /* Size of malloc() pool */
 #define CONFIG_SYS_MALLOC_LEN		(16 * SZ_1M)
-
 #define CONFIG_BOARD_EARLY_INIT_F
 #define CONFIG_BOARD_LATE_INIT
 #define CONFIG_MXC_GPIO
-
 #define CONFIG_MXC_UART
-
 #define CONFIG_CMD_FUSE
 #ifdef CONFIG_CMD_FUSE
 #define CONFIG_MXC_OCOTP
@@ -61,7 +57,6 @@
 #define CONFIG_FSL_ESDHC
 #define CONFIG_FSL_USDHC
 #define CONFIG_SYS_FSL_ESDHC_ADDR      0
-
 #define CONFIG_MMC
 #define CONFIG_CMD_MMC
 #define CONFIG_GENERIC_MMC
@@ -71,9 +66,9 @@
 #define CONFIG_CMD_EXT4_WRITE
 #define CONFIG_CMD_FAT
 #define CONFIG_DOS_PARTITION
-
 #define CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
 
+/* NET Configs */
 #define CONFIG_CMD_PING
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_MII
@@ -83,15 +78,17 @@
 #define IMX_FEC_BASE			ENET_BASE_ADDR
 #define CONFIG_FEC_XCV_TYPE		RGMII
 #define CONFIG_ETHPRIME			"FEC"
-#define CONFIG_FEC_MXC_PHYADDR		1
-
+#define CONFIG_FEC_MXC_PHYADDR		0x1F
+#define CONFIG_PHY_MICREL
+#define CONFIG_PHY_MICREL_KSZ9021
+#define CONFIG_PHY_MICREL_KSZ9031
 #define CONFIG_PHYLIB
 #define CONFIG_PHY_ATHEROS
 
 /* allow to overwrite serial and ethaddr */
 #define CONFIG_ENV_OVERWRITE
-#define CONFIG_CONS_INDEX              1
-#define CONFIG_BAUDRATE                        115200
+#define CONFIG_CONS_INDEX                1
+#define CONFIG_BAUDRATE                  115200
 
 /* Command definition */
 #include <config_cmd_default.h>
@@ -100,18 +97,10 @@
 #define CONFIG_CMD_BOOTZ
 #define CONFIG_CMD_SETEXPR
 #undef CONFIG_CMD_IMLS
-
-#define CONFIG_BOOTDELAY               1
-
-#define CONFIG_LOADADDR                        0x12000000
-#define CONFIG_SYS_TEXT_BASE           0x17800000
-#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
-
-#ifdef CONFIG_SYS_BOOT_NAND
-#define CONFIG_MFG_NAND_PARTITION "mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs) "
-#else
-#define CONFIG_MFG_NAND_PARTITION ""
-#endif
+#define CONFIG_BOOTDELAY                 1
+#define CONFIG_LOADADDR                  0x12000000
+#define CONFIG_SYS_TEXT_BASE             0x17800000
+#define CONFIG_SYS_MMC_IMG_LOAD_PART     1
 
 #define CONFIG_MFG_ENV_SETTINGS \
 	"mfgtool_args=setenv bootargs console=" CONFIG_CONSOLE_DEV ",115200 " \
@@ -121,15 +110,13 @@
 		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
 		"g_mass_storage.iSerialNumber=\"\" "\
 		"enable_wait_mode=off "\
-		CONFIG_MFG_NAND_PARTITION \
-		"\0" \
 		"initrd_addr=0x12C00000\0" \
 		"initrd_high=0xffffffff\0" \
-		"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+		"bootcmd_mfg=run mfgtool_args;bootm ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
 
 #ifdef CONFIG_SUPPORT_EMMC_BOOT
 #define EMMC_ENV \
-	"emmcdev=2\0" \
+	"emmcdev=0\0" \
 	"update_emmc_firmware=" \
 		"if test ${ip_dyn} = yes; then " \
 			"setenv get_cmd dhcp; " \
@@ -147,49 +134,12 @@
 #define EMMC_ENV ""
 #endif
 
-#if defined(CONFIG_SYS_BOOT_NAND)
-	/*
-	 * The dts also enables the WEIN NOR which is mtd0.
-	 * So the partions' layout for NAND is:
-	 *     mtd1: 16M      (uboot)
-	 *     mtd2: 16M      (kernel)
-	 *     mtd3: 16M      (dtb)
-	 *     mtd4: left     (rootfs)
-	 */
 #define CONFIG_EXTRA_ENV_SETTINGS \
 	CONFIG_MFG_ENV_SETTINGS \
-	"fdt_addr=0x18000000\0" \
-	"fdt_high=0xffffffff\0"	  \
-	"bootargs=console=" CONFIG_CONSOLE_DEV ",115200 ubi.mtd=4 "  \
-		"root=ubi0:rootfs rootfstype=ubifs "		     \
-		"mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs)\0"\
-	"bootcmd=nand read ${loadaddr} 0x4000000 0x800000;"\
-		"nand read ${fdt_addr} 0x5000000 0x100000;"\
-		"bootz ${loadaddr} - ${fdt_addr}\0"
-
-#elif defined(CONFIG_SYS_BOOT_SATA)
-
-#define CONFIG_EXTRA_ENV_SETTINGS \
-		CONFIG_MFG_ENV_SETTINGS \
-		"fdt_addr=0x18000000\0" \
-		"fdt_high=0xffffffff\0"   \
-		"bootargs=console=" CONFIG_CONSOLE_DEV ",115200 \0"\
-		"bootargs_sata=setenv bootargs ${bootargs} " \
-			"root=/dev/sda1 rootwait rw \0" \
-		"bootcmd_sata=run bootargs_sata; sata init; " \
-			"sata read ${loadaddr} 0x800  0x4000; " \
-			"sata read ${fdt_addr} 0x8000 0x800; " \
-			"bootz ${loadaddr} - ${fdt_addr} \0" \
-		"bootcmd=run bootcmd_sata \0"
-
-#else
-#define CONFIG_EXTRA_ENV_SETTINGS \
-	CONFIG_MFG_ENV_SETTINGS \
-	"epdc_waveform=epdc_splash.bin\0" \
-	"script=boot.scr\0" \
-	"image=zImage\0" \
+	"image=uImage\0" \
 	"fdt_file=" CONFIG_DEFAULT_FDT_FILE "\0" \
 	"fdt_addr=0x18000000\0" \
+	"ethprime=FEC0\0" \
 	"boot_fdt=try\0" \
 	"ip_dyn=yes\0" \
 	"console=" CONFIG_CONSOLE_DEV "\0" \
@@ -226,16 +176,16 @@
 		"run mmcargs; " \
 		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
 			"if run loadfdt; then " \
-				"bootz ${loadaddr} - ${fdt_addr}; " \
+				"bootm ${loadaddr} - ${fdt_addr}; " \
 			"else " \
 				"if test ${boot_fdt} = try; then " \
-					"bootz; " \
+					"bootm; " \
 				"else " \
 					"echo WARN: Cannot load the DT; " \
 				"fi; " \
 			"fi; " \
 		"else " \
-			"bootz; " \
+			"bootm; " \
 		"fi;\0" \
 	"netargs=setenv bootargs console=${console},${baudrate} ${smp} " \
 		"root=/dev/nfs " \
@@ -250,16 +200,16 @@
 		"${get_cmd} ${image}; " \
 		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
 			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
-				"bootz ${loadaddr} - ${fdt_addr}; " \
+				"bootm ${loadaddr} - ${fdt_addr}; " \
 			"else " \
 				"if test ${boot_fdt} = try; then " \
-					"bootz; " \
+					"bootm; " \
 				"else " \
 					"echo WARN: Cannot load the DT; " \
 				"fi; " \
 			"fi; " \
 		"else " \
-			"bootz; " \
+			"bootm; " \
 		"fi;\0"
 
 #define CONFIG_BOOTCOMMAND \
@@ -274,7 +224,6 @@
 			"fi; " \
 		"fi; " \
 	"else run netboot; fi"
-#endif
 
 #define CONFIG_ARP_TIMEOUT     200UL
 
@@ -282,6 +231,7 @@
 #define CONFIG_SYS_LONGHELP
 #define CONFIG_SYS_HUSH_PARSER
 #define CONFIG_SYS_PROMPT_HUSH_PS2     "> "
+#define CONFIG_SYS_PROMPT	       "i.Mx6-solosabreauto > "
 #define CONFIG_AUTO_COMPLETE
 #define CONFIG_SYS_CBSIZE              1024
 
@@ -289,21 +239,17 @@
 #define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
 #define CONFIG_SYS_MAXARGS             256
 #define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
-
 #define CONFIG_CMD_MEMTEST
 #define CONFIG_SYS_MEMTEST_START       0x10000000
 #define CONFIG_SYS_MEMTEST_END         0x10010000
 #define CONFIG_SYS_MEMTEST_SCRATCH     0x10800000
-
 #define CONFIG_SYS_LOAD_ADDR           CONFIG_LOADADDR
-
 #define CONFIG_CMDLINE_EDITING
 #define CONFIG_STACKSIZE               (128 * 1024)
 
 /* Physical Memory Map */
 #define CONFIG_NR_DRAM_BANKS           1
 #define PHYS_SDRAM                     MMDC0_ARB_BASE_ADDR
-
 #define CONFIG_SYS_SDRAM_BASE          PHYS_SDRAM
 #define CONFIG_SYS_INIT_RAM_ADDR       IRAM_BASE_ADDR
 #define CONFIG_SYS_INIT_RAM_SIZE       IRAM_SIZE
@@ -315,9 +261,7 @@
 
 /* FLASH and environment organization */
 #define CONFIG_SYS_NO_FLASH
-
 #define CONFIG_ENV_SIZE			(8 * 1024)
-
 #ifndef CONFIG_SYS_NOSMP
 #define CONFIG_SYS_NOSMP
 #endif
@@ -325,67 +269,20 @@
 #if defined CONFIG_SYS_BOOT_SPINOR
 #define CONFIG_SYS_USE_SPINOR
 #define CONFIG_ENV_IS_IN_SPI_FLASH
-#elif defined CONFIG_SYS_BOOT_EIMNOR
-#define CONFIG_SYS_USE_EIMNOR
-#define CONFIG_ENV_IS_IN_FLASH
-#elif defined CONFIG_SYS_BOOT_NAND
-#define CONFIG_SYS_USE_NAND
-#define CONFIG_ENV_IS_IN_NAND
-#elif defined CONFIG_SYS_BOOT_SATA
-#define CONFIG_ENV_IS_IN_SATA
-#define CONFIG_CMD_SATA
 #else
 #define CONFIG_ENV_IS_IN_MMC
 #endif
 
-#ifdef CONFIG_CMD_SATA
-#define CONFIG_DWC_AHSATA
-#define CONFIG_SYS_SATA_MAX_DEVICE	1
-#define CONFIG_DWC_AHSATA_PORT_ID	0
-#define CONFIG_DWC_AHSATA_BASE_ADDR	SATA_ARB_BASE_ADDR
-#define CONFIG_LBA48
-#define CONFIG_LIBATA
-#endif
-
 #ifdef CONFIG_SYS_USE_SPINOR
 #define CONFIG_CMD_SF
 #define CONFIG_SPI_FLASH
-#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_SPI_FLASH_ISSI
 #define CONFIG_MXC_SPI
 #define CONFIG_SF_DEFAULT_BUS  0
 #define CONFIG_SF_DEFAULT_SPEED 20000000
 #define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
 #endif
 
-#ifdef CONFIG_SYS_USE_EIMNOR
-#undef CONFIG_SYS_NO_FLASH
-#define CONFIG_SYS_FLASH_BASE           WEIM_ARB_BASE_ADDR
-#define CONFIG_SYS_FLASH_SECT_SIZE     (128 * 1024)
-#define CONFIG_SYS_MAX_FLASH_BANKS 1    /* max number of memory banks */
-#define CONFIG_SYS_MAX_FLASH_SECT 256   /* max number of sectors on one chip */
-#define CONFIG_SYS_FLASH_CFI            /* Flash memory is CFI compliant */
-#define CONFIG_FLASH_CFI_DRIVER         /* Use drivers/cfi_flash.c */
-#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE /* Use buffered writes*/
-#define CONFIG_SYS_FLASH_EMPTY_INFO
-#endif
-
-#ifdef CONFIG_SYS_USE_NAND
-#define CONFIG_CMD_NAND
-#define CONFIG_CMD_NAND_TRIMFFS
-
-/* NAND stuff */
-#define CONFIG_NAND_MXS
-#define CONFIG_SYS_MAX_NAND_DEVICE     1
-#define CONFIG_SYS_NAND_BASE           0x40000000
-#define CONFIG_SYS_NAND_5_ADDR_CYCLE
-#define CONFIG_SYS_NAND_ONFI_DETECTION
-
-/* DMA stuff, needed for GPMI/MXS NAND support */
-#define CONFIG_APBH_DMA
-#define CONFIG_APBH_DMA_BURST
-#define CONFIG_APBH_DMA_BURST8
-#endif
-
 #if defined(CONFIG_ENV_IS_IN_MMC)
 #define CONFIG_ENV_OFFSET		(8 * 64 * 1024)
 #elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
@@ -412,7 +309,6 @@
 #endif
 
 #define CONFIG_OF_LIBFDT
-
 #ifndef CONFIG_SYS_DCACHE_OFF
 #define CONFIG_CMD_CACHE
 #endif
@@ -423,28 +319,4 @@
 #define CONFIG_SYS_I2C_MXC
 #define CONFIG_SYS_I2C_SPEED		  100000
 
-/* Framebuffer */
-#define CONFIG_VIDEO
-#define CONFIG_VIDEO_IPUV3
-#define CONFIG_CFB_CONSOLE
-#define CONFIG_VGA_AS_SINGLE_DEVICE
-#define CONFIG_SYS_CONSOLE_IS_IN_ENV
-#define CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE
-#define CONFIG_VIDEO_BMP_RLE8
-#define CONFIG_SPLASH_SCREEN
-#define CONFIG_SPLASH_SCREEN_ALIGN
-#define CONFIG_BMP_16BPP
-#define CONFIG_VIDEO_LOGO
-#define CONFIG_VIDEO_BMP_LOGO
-#ifdef CONFIG_MX6DL
-#define CONFIG_IPUV3_CLK 198000000
-#else
-#define CONFIG_IPUV3_CLK 264000000
-#endif
-#define CONFIG_IMX_HDMI
-#define CONFIG_IMX_VIDEO_SKIP
-
-#if defined(CONFIG_ANDROID_SUPPORT)
-#include "mx6sabreandroid_common.h"
-#endif
 #endif                         /* __MX6QSABRE_COMMON_CONFIG_H */
diff -Naur a/include/micrel.h b/include/micrel.h
--- a/include/micrel.h	2020-09-07 09:01:44.622208772 +0530
+++ b/include/micrel.h	2020-09-07 09:45:30.526160935 +0530
@@ -15,6 +15,14 @@
 #define MII_KSZ9031_MOD_DATA_POST_INC_RW	0x8000
 #define MII_KSZ9031_MOD_DATA_POST_INC_W		0xC000
 
+#define MII_KSZ9031_EXT_MMD_ADD_MASK            0x1F
+#define MII_KSZ9031_EXT_MMD_ADD1                0x01
+#define MII_KSZ9031_EXT_MMD_ADD2                0x02
+
+#define MII_KSZ9031_EXT_COMMON_CTRL             0x00
+#define MII_KSZ9031_EXT_STRAP_STATUS            0x01
+#define MII_KSZ9031_EXT_OP_STRAP_OVERRIDE       0x02
+#define MII_KSZ9031_EXT_OP_STRAP_STATUS         0x03
 #define MII_KSZ9031_EXT_RGMII_CTRL_SIG_SKEW	0x4
 #define MII_KSZ9031_EXT_RGMII_RX_DATA_SKEW	0x5
 #define MII_KSZ9031_EXT_RGMII_TX_DATA_SKEW	0x6
@@ -30,3 +38,4 @@
 			      int regnum, u16 mode);
 
 #endif
+
